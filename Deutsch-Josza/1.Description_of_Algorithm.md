<h1> Deutsch-Josza Algorithm </h1>

</br></br>

<h2>Problem</h2>
  
Consider being given some hidden Boolean function __*f*__ where __*f(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>)*__ maps each __*x<sub>i</sub>*__ to __*0*__ or __*1*__. </br></br>
The function is, however, known to be either balanced or constant. This implies that the function __*f*__ only returns a specific value (it could be only __1__ or only __0__) or it returns exactly half of all the answers as __0__ and exactly half of the other answers as __1__.
</br>
</br>
We are asked to determine whether __*f*__ is balanced or constant.

</br></br>

<h2>Classical Solution</h2>

The solution may be found in the best case by evaluating __*f*__ with different values twice. If the two answers are not the same we know that __*f*__ is balanced.

In the worst case we wil need to evaluate __*f*__ a total of __*2 <sup>n</sup> + 1*__ times to ensure it is constant.

</br></br>

<h2>Quantum Solution</h2>

The solution to this problem may found with only __*1*__ iteration using a quantum computer.

</br>

__The Algorithm__

1. Setup __*n + 1*__ qubit registers where __*n*__ is the number of inputs initialised to __|0>__, except for the last register, which is initialised to __*|1>*__.
2. Apply a Hadamard Gate over every qubit register.
3. Apply __*f*__ (A.K.A the oracle) over every qubit.
4. Apply a Hadamard to every qubit, except for the last.
5. Measure each register, except for the last.

</br>

__The Quantum Circuit__

![Deutsch_Josza_Circuit_1](https://user-images.githubusercontent.com/68278907/87456546-63396d00-c607-11ea-9977-8daee8133bed.jpg)


__The unkown function/Oracle__

Although the initial problem is to solve an unkown function setup, we need to paradoxically know what the funcion is for us to build it's circuit.

For a __constant__ function: 
